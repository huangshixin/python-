import numpy as np
import  random as rd
from 数据分析.numpy包.test import create_ones

#向量化和广播
"""
向量化：
，编写代码时无需使用显式循环。这些循环实际上不能省略，
只不过是在内 部实现，被代码中的其他结构代替。向量化的
应用使得代码更简洁，可读性更强，也可以说使用了向量化方
法的代码看上去更“Pythonic”。

广播：
机制描述了 numpy 如何在算术运算期间处理具有不同形状的
数组，让较小的数组在较大的数组上“广播”，以便它们具有
兼容的形状。并不是所有的维度都要彼此兼容才符合广播机制
的要求，但它们必须满足一定的条件。

广播三规则：
1. 如果两个数的维度数dim不组相同，那么小维度数组的形状将会在左边补1。
2. 如果shape维度不匹配，但是有维度是1，那么可以扩展维度是1的维度匹配另一个数组； 
3. 如果shape维度不匹配，但是没有任何一个维度是1，则匹配引发错

"""
"""
能够想象到的广播的作用就是
在resnet中需要的矩阵的加法运算
x = np.random.rand() 返回0-1中的一个数据，如果你写的是rand（5，5）则返回一个和数据
x=np.around(input,小数点后几位） 主要看你想保留几位数字
x=np.arange(4)    创建一个      列表     返回0-3
shape
x=np.eye(5)返回对角线全为1的数
"""
x=np.arange(4)
y=np.ones((3,4))
print(x,x.shape)
print(y,y.shape,end='\n')
# [0 1 2 3] (4,)
# [[1. 1. 1. 1.]
#  [1. 1. 1. 1.]
#  [1. 1. 1. 1.]] (3, 4)
print((x+y).shape)
print(x+y)#这方式加法是每个位置上都加上（比如一个矩阵和列表相加，我们希望每一行或者每一列都加上一样的值 则使用这种方式
# (3, 4)
# [[1. 2. 3. 4.]
#  [1. 2. 3. 4.]
#  [1. 2. 3. 4.]]

#58  file:///D:/深度学习总结笔记/数据集/numpy学习文件/十月组队学习_Numpy_上.pdf




"""广播"""
x = np.arange(4).reshape(4, 1)#本来列表横着写，现在变列的
y = np.ones(5)
print(x)
print(x.shape) # (4, 1)
print(y.shape) # (5,)
print((x + y).shape) # (4, 5)
print(x + y)
"""
x=[[0]
 [1]
 [2]
 [3]]
y=[1. 1. 1. 1. 1.]
相当于，在x的每一层都用 该层的数据加上 y的每一层的值
但是由于y是一个列表，所以相加成的结过是 一个矩阵
"""
# [[1. 1. 1. 1. 1.]
# [2. 2. 2. 2. 2.]
# [3. 3. 3. 3. 3.]
# [4. 4. 4. 4. 4.]]
#举例

new_x=np.arange(5).reshape(5,1)
y=np.array([1,3,5,7,9])
print(new_x.shape,new_x,end='\n')
print(y.shape)

print("结合的结构：\n",new_x+y)
# (5, 1)
# [[0]
#  [1]
#  [2]
#  [3]
#  [4]]
# (5,)
# 结合的结构：
#  [[ 1  3  5  7  9]
#  [ 2  4  6  8 10]
#  [ 3  5  7  9 11]
#  [ 4  6  8 10 12]
#  [ 5  7  9 11 13]]






x = np.array([0.0, 10.0, 20.0, 30.0])
y = np.array([1.0, 2.0, 3.0])
z = x[:, np.newaxis] + y
print(z)
# [[ 1. 2. 3.]
# [11. 12. 13.]
# [21. 22. 23.]
# [31. 32. 33.]]

#
# import numpy as np
# x = np.arange(4)
# y = np.ones(5)
# print(x.shape) # (4,)
# print(y.shape) # (5,)
# print(x + y)


















































