redo 操作保证了事务的【持久性】
undo 保证了原子性和一致性； 原子性就是不可分割，一致性，同时执行




【锁】

为什么要需要对系统的资源加上锁呢？

      锁现在是为了需要对 【并发操作进行控制】--------所以说事务的【隔离性】由锁来实现
      
      
      
2. MySQL并发事务访问相同记录
并发事务访问相同记录的情况大致可以划分为3种：

2.1 读-读情况
读-读 情况，即并发事务相继 读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么
问题，所以允许这种情况的发生。

2.2 写-写情况
写-写 情况，即并发事务相继对相同的记录做出改动。
在这种情况下会发生 脏写 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务
相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 锁 来实现的。      
      
【一起读，不会出现问题，但是一起写入数据，那么可能出现脏写】
如果一个写，一个在读，可能会出现‘脏读’；
      
当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的【 锁结构 】，当没有的时候就会在内存中生成一个 锁结构 与之关联。
  
  
2.3 读-写或写-读情况
读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重
复读 、 幻读 的问题。
各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经
解决了 幻读 问题。
  
    
  
  
  
2.4 并发问题的解决方案

怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢？其实有两种可选的解决方案：
方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行 加锁 。
普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。
在 READ COMMITTED 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一
个ReadView，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就
是避免了脏读现象；
在 REPEATABLE READ 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会
生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读
和幻读的问题。
方案二：读、写操作都采用 加锁 的方式。
小结对比发现：
采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 。
采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能。
一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况
下，要求必须采用 加锁 的方式执行。下面就讲解下MySQL中不同类别的锁。  
  
  
  
